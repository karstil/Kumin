# Universal Coding Rules (Language-Agnostic and Language-Specific)

In modern AI-assisted development, it's crucial to maintain consistent coding standards. Below is a comprehensive, categorized list of coding guidelines. These include language-agnostic best practices as well as specific rules for Java, Kotlin, and JavaScript/TypeScript. Each rule is concise and designed for easy reference by both developers and AI coding agents.

## Language-Agnostic Best Practices

### Code Style & Readability
- **Prioritize Readability:** Write code for humans first – prioritize clarity over cleverness. *Code is read far more often than it is written*. Always format and structure your code to be easy to follow.
- **Follow Consistent Formatting:** Adhere to a consistent indentation, bracing style, and spacing convention across the codebase. If no standard exists, pick one and stick to it – consistency is more important than the exact style.
- **Limit Line Length:** Keep lines of code reasonably short (e.g. 100 characters or less) to avoid horizontal scrolling. This improves readability, especially when reviewing diffs.
- **Keep Functions Small:** Each function should ideally do one thing. Short functions (~20 lines or less) are easier to understand and maintain. If a function is doing too much, consider refactoring into smaller helper functions.
- **Use Early Returns to Reduce Nesting:** Where possible, handle edge cases or error conditions early in a function and return, rather than nesting the main logic inside multiple `if` levels. This makes code less indented and more linear, improving clarity.
- **Avoid Magic Numbers/Strings:** **Do not hard-code** unexplained constants in code. Use named constants or enums for fixed values to give them meaning. This makes code self-documenting and easier to change in one place later.
- **Dry Principle (DRY):** **Don't Repeat Yourself** – avoid duplicating code. If you find the same code in multiple places, refactor into a single function or module. As a guideline, once you use similar code a *third* time, refactor it into a shared utility.
- **KISS Principle:** **Keep It Simple** – simplicity and clarity are key. Don't over-engineer solutions. For example, a clear 10-line solution is better than a clever 1-liner that's hard to understand. *Simple, small functions* are easier to read and maintain than complex ones.
- **YAGNI:** **You Aren't Gonna Need It** – don't add functionality or code that isn't needed for the requirements. Extra code for hypothetical future use increases complexity; you can always extend later when needed.

### Naming Conventions
- **Use Descriptive, Intention-Revealing Names:** Choose variable, function, and class names that clearly indicate their purpose. Avoid one-letter or cryptic names (except for very short scopes like lambda indices). For example, `tokenExpirationDate` is better than `date1`.
- **Be Consistent with Terminology:** Use the same term for the same concept throughout the codebase. Don't use synonyms or different words (`getUser` vs `fetchUser` vs `retrieveUser`) for the same operation – pick one and stick to it to avoid confusion.
- **Establish Naming Standards:** Follow standard naming conventions for each language and project. For instance, **camelCase** for variables/functions and **PascalCase** for classes/types are common in many languages. Consistency helps different modules and contributors produce indistinguishable code.
- **Avoid Misleading Names:** Names should accurately describe. Don't use names that might hint at the wrong thing (e.g. naming an array `userList` if it's not actually a list data structure). Ensure that a reader's expectations from a name match the reality.
- **No Hungarian Notation or Type Encoding:** Do not encode types or scopes in names (e.g. no `szName` or `m_var` prefixes). Modern languages and IDEs make this unnecessary. Names should describe intent, not the variable's type or how it's used in memory.
- **Class and Method Naming:** Use **nouns or noun phrases** for class names, and **verbs or verb phrases** for methods/functions to indicate action. For example, `InvoiceGenerator` (class) and `generateInvoice()` (method). This aligns with common OOP conventions and clarity.
- **Capitalization Conventions:** Adhere to language-specific case conventions:
    - *Classes/Types:* **UpperCamelCase** (e.g. `DataProcessor`).
    - *Variables/Functions:* **lowerCamelCase** (e.g. `maxRetries` for a variable, `calculateTotal()` for a method).
    - *Constants:* **UPPERCASE_WITH_UNDERSCORES** for constants or immutable values (e.g. `MAX_CONNECTIONS`).
    - *Packages/Namespaces:* usually all-lowercase (and dot-separated for Java/Kotlin packages).

### Comments & Documentation
- **Code Should Explain Itself:** Strive to write self-explanatory code using clear names and simple logic. **Use comments sparingly**, primarily to explain *why* something is done if it's not obvious, or to provide context. Avoid comments that simply restate what the code does.
- **Document Public APIs:** Provide documentation comments (Javadoc, KDoc, JSDoc, etc.) for public classes, functions, and modules explaining their behavior, parameters, return values, and side effects. This helps both colleagues and AI agents understand usage.
- **Avoid Redundant or Obsolete Comments:** Remove or update comments that are outdated or no longer accurate. Incorrect comments are worse than none. *Do not use comments as a band-aid for confusing code* – refactor the code if possible, instead of writing a long comment to explain it.
- **No Commented-Out Code:** **Do not leave blocks of commented-out code** in the codebase. If code isn't needed, remove it (version control can retrieve it later if required). Commented code accumulates rot and confusion over time.
- **Inline Comments Judiciously:** Avoid inline comments inside functions that explain *how* the code works step-by-step – if the code needs that, consider refactoring to be cleaner. Instead, use a comment to clarify intent when introducing non-obvious logic or workarounds. Keep such comments short and near the code they explain.
- **Comment Style:** When writing comments, be clear and concise. For multi-line explanations, use proper comment blocks or doc comments. For quick clarifications, a single-line `// ...` is fine. In any case, ensure the comment is formatted in a way that doesn't interrupt code flow.

### Design Principles & Maintainability
- **Single Responsibility:** Each module, class, or function should have a single responsibility or concern. This makes understanding and modifying code easier. If you find a function doing too many unrelated things, consider splitting it up.
- **Encapsulation:** **Encapsulate data and implementation details.** Keep class fields `private` and expose needed access via methods (getters/setters) if necessary. This prevents external code from putting your objects into invalid states and allows you to change implementations without breaking callers.
- **Minimize Global/Shared State:** Avoid global variables or excessive use of singletons. Rely on function parameters and return values or well-defined class interfaces to pass data. Global state can lead to tight coupling and unpredictable behavior, so prefer dependency injection or singleton usage only where appropriate and safe.
- **Immutability Where Possible:** Prefer immutable data structures and objects where feasible. For example, use immutable value objects or make fields `final` (Java) or `val` (Kotlin) by default. Immutable objects are simpler to reason about (especially in concurrent contexts) and avoid unintended side-effects.
- **DRY & Abstraction:** As noted earlier, avoid duplicating code. Use abstraction to generalize common functionality. This could mean creating utility functions, base classes, or using design patterns (like strategy or template method) to handle variations. Duplication is a missed opportunity to abstract and can lead to inconsistencies.
- **Keep Scope Small:** Declare variables in the narrowest scope possible (i.e., inside blocks or functions rather than as globals). For instance, limit local variables to the smallest necessary block and initialize them close to their usage. This improves readability and reduces the chance of errors by limiting "live" time of data.
- **Boy Scout Rule:** Leave the code **cleaner than you found it**. Whenever you touch code, if you see small issues (typos, minor bugs, poor names, lack of clarity), consider fixing them as you go (assuming it's within scope). Over time, this continuous improvement keeps the codebase healthy.
- **Consistent Patterns:** Use consistent patterns for similar tasks. For example, if your team has a standard way to handle errors, log information, or structure modules, follow that pattern everywhere. *Inconsistency is a code smell* – developers (and AI agents) should not have to learn multiple ways to do the same thing in one codebase.
- **Avoid Over-Engineering:** Choose the simplest solution that works and is clear. Don't introduce needless complexity (extra layers, generic abstractions, premature design patterns) for a problem that doesn't require it. Over-engineering can make maintenance hard; you can extend or refactor when new requirements emerge (see YAGNI principle).

### Error Handling & Security
- **Handle Exceptions and Errors:** Always handle errors appropriately – never just ignore or swallow exceptions silently. Catch exceptions where you can either **recover or add context**, and otherwise let them propagate. For example, catch an exception to log a friendly message or to wrap it in a higher-level exception with more context, then rethrow. If you can't handle it meaningfully, it's often better not to catch it at that layer.
- **Don't Catch Generic Exceptions Unnecessarily:** Avoid catching overly broad exception types (like `Exception` or `Throwable` in Java) unless you truly intend to handle *all* cases. Catch the specific exceptions you expect and can resolve. A blanket catch-all can mask bugs and make troubleshooting harder. (One acceptable use of a broad catch is at a top-level boundary to log and terminate gracefully, but even then, consider logging and rethrowing or exiting.)
- **Fail Fast:** If bad data or an impossible situation is encountered, consider failing fast with an error (throwing an exception or similar) rather than proceeding in a corrupt state. This makes bugs visible earlier rather than later. For example, use assertions or explicit checks on critical assumptions and input validation to catch issues early.
- **Validate Inputs:** Always validate external inputs (user input, external API data, etc.) before using them. This is crucial for both correctness and security (to prevent, for instance, injection attacks or crashes due to malformed data). For example, check for null or empty values, ranges of numbers, allowed formats, etc., and handle validation failures gracefully (e.g., return an error message, throw `IllegalArgumentException`, etc.).
- **Resource Management:** Clean up resources (files, network connections, database handles) after use to prevent leaks. Use language features or libraries that ensure deterministic cleanup (e.g. try-with-resources in Java, `use` blocks in Kotlin, or finally blocks in other languages). This also includes unsubscribing from listeners or freeing any system resources when they are no longer needed.
- **Logging and Monitoring:** When catching exceptions or handling errors, log useful information about them (but avoid logging sensitive data). This aids in debugging and production monitoring. Ensure log messages are clear and actionable. However, do not log excessively inside tight loops or low-level operations (to avoid performance overhead and log noise) – focus on meaningful events.
- **Security Best Practices:** Never hard-code secrets (passwords, API keys) in code. Use secure storage or environment configurations for such data. Also sanitize any data that goes into SQL queries or system commands to prevent injection vulnerabilities. While this is a broad area, a simple rule is: *treat all external input as untrusted and handle it accordingly (validate, sanitize, encode, etc.)*.

### Testing & Quality
- **Write Tests for Critical Code:** Ensure important logic is covered by automated tests (unit tests, integration tests). If you fix a bug, add a test to prevent regression. This not only helps catch issues early but also gives AI agents context on expected behavior.
- **Aim for Small, Modular Functions (for Testability):** Functions that do one thing and have minimal side effects are easier to test. Design code so that core logic can be tested without a complex environment setup when possible. For example, keep business logic separate from I/O or UI, so it can be tested in isolation.
- **Use Code Analysis Tools:** Employ linters, formatters, and static analysis tools to catch style issues, common bugs, or bad practices automatically. For example, use ESLint/Prettier for JavaScript/TypeScript, ktlint or detekt for Kotlin, and Checkstyle/SpotBugs or SonarQube for Java. An automated tool enforces standards and catches issues consistently.
- **Continuous Improvement:** If the codebase has existing issues (code smells, failing tests, etc.), gradually fix them as you touch those areas. Don't ignore failing tests or warnings. Keeping the build green and the static analysis warnings low ensures quality remains high over time.
- **Performance Consciousness:** Write clear code first, but be aware of performance in critical sections. Use efficient algorithms and data structures appropriate to the problem. However, avoid micro-optimizing prematurely – don't sacrifice much readability for minor performance gains unless profiling shows it's needed. High-level best practice: choose the correct approach (e.g., avoid O(n²) loops on large data sets, prefer streaming or lazy evaluation for large collections if memory is a concern, etc.), but always verify with measurements if performance is critical.

---

## Java-Specific Guidelines
These rules apply to Java (in addition to the general ones above) and reflect typical Java coding conventions and best practices.

### Java Style & Conventions
- **Java Naming Conventions:**
    - *Classes/Interfaces:* Use **PascalCase** (e.g. `OrderService`, `MyUtils`). Class names are usually nouns or noun phrases.
    - *Methods & Variables:* Use **camelCase** starting with lowercase (e.g. `processOrder`, `maxRetries`). Method names typically begin with a verb reflecting their action.
    - *Constants:* For static final constants, use **ALL_CAPS** with underscores (e.g. `MAX_CONNECTIONS`). This signals that the value is a compile-time constant.
    - *Packages:* Use all-lowercase package names (typically dot-separated words, e.g. `com.mycompany.project`). Avoid underscores or camelCase in package names.
- **Braces and Formatting:** Follow standard Java brace style. For example, use braces for every `if/else/for/while` block even if it's one line (this prevents errors when adding new lines later). Indent using 4 spaces (or the project standard) consistently. Use blank lines to separate logical sections of code, but not excessively. Leverage your IDE's auto-format feature (configured to project style) to maintain consistency.
- **File Organization:** One top-level public class per `.java` file (with file name matching class name). Order of contents in a class: usually constants first, then fields, then constructors, then methods. Group related methods together (e.g., private helper methods after the public methods they support, or override methods together). This makes the code easier to navigate.
- **Use Javadoc Comments for Public APIs:** Document the purpose of classes, methods, parameters, and return values using Javadoc. For any public or widely used component, a one- or two-sentence description plus `@param` / `@return` tags greatly improves understandability for other developers and AI tools.

### Java Object-Oriented Best Practices
- **Encapsulation & Access Modifiers:** Make fields `private` unless there's a very good reason to expose them. Use getters and setters to control access if needed (and in setters, you can validate inputs). This protects invariants of your classes. Also, consider using package-private (default) or `protected` for classes and methods that are internal to a module/API – don't make everything `public` by default. Minimize the accessibility of classes and members to only what is necessary.
- **Minimize Mutability:** Favor immutable classes or at least effectively immutable patterns for data-holding objects. For example, create classes whose fields are set in the constructor and never change, or use records (Java 16+) for simple data carriers. If full immutability isn't feasible, still reduce mutability: use `final` on fields where possible, and avoid exposing setters for fields that shouldn't change after construction. Immutable objects are simpler to reason about and inherently thread-safe.
- **Prefer Interfaces over Implementation Types:** Write code against interfaces or abstract base classes rather than concrete implementations when possible. For example, declare variables as `List<String>` instead of `ArrayList<String>` if any List implementation would work. This makes code more flexible and testable (you can swap implementations). Also, consider using Java's functional interfaces or lambda expressions for flexibility in behavior.
- **Use Inheritance Judiciously:** Favor composition over inheritance when appropriate. Inheritance can lead to tight coupling; consider whether a class "is-a" truly fits, or if "has-a" (using a field) is better. If you do use inheritance, ensure Liskov Substitution Principle holds (subclasses can stand in for base classes without surprising behavior).
- **Design by Contract:** For public methods, use explicit checks at the start to validate arguments (throwing `IllegalArgumentException` or similar for invalid inputs). This documents the expectations and fails fast. Use Java's `Objects.requireNonNull(param, "message")` to catch nulls early for parameters that must not be null.
- **Override `toString`, `equals`, and `hashCode` when appropriate:** For data classes, provide a meaningful `toString()` for easier debugging/logging. If objects of a class are compared or used in collections, override `equals()` and `hashCode()` consistently (or use record or Lombok `@Data` which generates them). Follow the contract that equal objects must have equal hashCodes.
- **Avoid `Object...` Misuse:** Use varargs (`Object...`) parameters sparingly – usually only for methods explicitly designed to take an arbitrary number of arguments (like `String.format`). Overusing varargs can lead to runtime errors (if wrong types are passed) and can hide the intended API contract.

### Java Memory & Resource Management
- **Use Try-with-Resources:** When working with any resource that implements `AutoCloseable` (files, streams, database connections, etc.), use the try-with-resources statement to ensure it is closed automatically. This prevents resource leaks even if exceptions occur. For example: `try (FileWriter w = new FileWriter(file)) { /* use w */ }` // closed automatically
- **Avoid Finalizers and Cleaners:** Don't rely on `finalize()` (which is deprecated) or cleaners for resource cleanup. They run unpredictably (or not at all). Use explicit try-with-resources or close calls.
- **Manage Memory Thoughtfully:** Java has garbage collection, but be mindful of large data structures and object creation in hot loops. For example, reuse objects or buffers when appropriate to avoid excessive GC pressure (but do not micro-optimize object creation unless profiling indicates an issue). A common practice is to use `StringBuilder` for concatenating many strings instead of using `+` in a loop.
- **Collections & Streams:** Choose the right collection for the job (e.g., `ArrayList` vs `LinkedList`, `HashMap` vs `TreeMap`). Be aware of the complexity: for instance, searching in a `List` is O(n), but a `HashSet` is O(1) on average. When processing collections, Java 8+ streams can make code concise, but ensure the stream operations are clear and not overly complex. For simple loops, a traditional for loop can sometimes be more straightforward. Prefer clarity over clever stream pipelines if it hurts readability.
- **Concurrency:** If writing multi-threaded code, prefer using high-level concurrency utilities from `java.util.concurrent` (like `ExecutorService`, `ConcurrentHashMap`, semaphores, etc.) instead of low-level Thread manipulation. Always protect shared mutable data with appropriate synchronization or use thread-safe structures. Avoid calling thread-blocking operations on typical application threads (like not performing long I/O on the UI/FX thread or an Executor's worker that isn't meant for blocking tasks).
- **Exception Handling in Resources:** When catching exceptions, consider wrapping or rethrowing after releasing resources. Never ignore exceptions from `close()` silently; if needed, catch and log them. When multiple exceptions happen in a try-with-resources (one in body, one in close), be aware that the one in close is suppressed – handle accordingly (e.g., log the suppressed exceptions if relevant).

### Java Best Practices & Idioms
- **Use Standard Libraries:** Don't reinvent the wheel. Leverage Java's standard library and well-established libraries for common tasks. For example, use `java.time` (JSR-310) for dates and times (instead of old Date or Calendar APIs), use streams or collectors for common collection transformations, use libraries like Apache Commons or Google Guava for utilities (if allowed by project) instead of writing your own from scratch. Standard libraries are thoroughly tested and familiar to other developers.
- **Logging Over `System.out`:** Use a logging framework (like Java Util Logging, Log4j2, SLF4J) for outputting information, rather than `System.out.println` or `System.err`. Logging frameworks allow level control (info, debug, error) and better formatting. Ensure not to log sensitive info (like passwords).
- **Avoid Premature Optimization:** Write clear, straightforward code. Optimize algorithms or critical sections after profiling. For example, avoid micro-optimizations like caching variables that the JIT/compiler will optimize anyway. Focus on big picture (choosing the right data structures, minimizing I/O, using batching if needed for DB operations, etc.) but only optimize further when a real performance need is identified.
- **Use Appropriate Data Types:** Use primitive types instead of their Wrapper classes when you don't need the object features (to avoid nulls and extra overhead). For example, prefer `int` over `Integer` in most cases for counters or calculations. Use `StringBuilder` for building large strings. For flags, use `boolean` rather than something like an `int` 0/1.
- **Null Handling:** In Java, null can be error-prone. Where practical, consider returning empty collections or `Optional<T>` instead of null to represent "no result" from methods (but don't overuse Optional for every single return – primarily for return values that might legitimately be absent). Always check for null on inputs that come from external code if they aren't guaranteed by your API. Consider using `Objects.requireNonNull` for constructor parameters to fail fast if null is passed for a required field.
- **Immutable Collections:** If you have collections that should not be modified after setup, wrap them with `Collections.unmodifiableList/set/map` when exposing them, or use Java 9+ convenient factory methods (which produce immutable collections) like `List.of(...)`. This prevents accidental modifications from outside and makes intent clear.

---

## Kotlin-Specific Guidelines
Kotlin, while running on the JVM like Java, has its own idiomatic style and language features. These guidelines help write idiomatic Kotlin that leverages Kotlin's strengths.

### Kotlin Style & Idioms
- **Kotlin Naming Conventions:** Kotlin follows similar naming conventions to Java for the most part:
    - *Classes/Objects:* **UpperCamelCase** (e.g. `DataRepository`).
    - *Functions and properties:* **lowerCamelCase** (e.g. `calculateTotal`, `isVisible`).
    - *Constants:* Use uppercase with underscores if using `const val` (top-level or in objects) for truly constant values. Otherwise, prefer `val` properties for immutable values.
    - *Package names:* lowercase, no underscores (same as Java).
- **Use `val` by Default:** Prefer `val` (immutable reference) for declaring variables. Only use `var` if the value truly needs to change. Immutability is encouraged in Kotlin – it makes reasoning about code easier and avoids accidental reassignments.
- **Leverage Type Inference:** You usually don't need to explicitly declare the type of local variables if it's obvious from the initializer. Write `val user = User("Alice")` instead of `val user: User = User("Alice")`. However, do specify types for public API functions and properties for clarity and documentation.
- **String Templates:** Use Kotlin's string template feature instead of string concatenation. E.g., `println("Hello, $name!")` is clearer than concatenation. This improves readability and reduces errors in string construction.
- **Expression Bodies:** Use expression body syntax for simple functions (especially one-liners). For example: `fun add(a: Int, b: Int) = a + b`. This is concise and clear for simple computations. Use the normal `{ ... }` body for more complex functions or where you need multiple statements.
- **Idiomatic Null Handling:** Embrace Kotlin's null-safety features:
    - Use nullable types (`String?`) when a value can be null, and handle nulls using safe calls (`?.` operator) or Elvis operator (`?:`) to provide defaults.
    - Avoid using the non-null assertion operator `!!` unless absolutely necessary – it will throw at runtime if you were wrong. Instead, prefer safe calls or explicit checks. Only use `!!` in cases where you're certain a value isn't null but the type system can't know (and even then, consider redesigning so that certainty is reflected in types).
    - Leverage `let`, `?.` and `?:` to deal with nullable values succinctly. For example: `user?.let { sendEmail(it) } ?: println("No user to email.")`
- **Data Classes for Data Containers:** Use `data class` for classes that are primarily holding data. Data classes automatically provide `equals/hashCode`, `toString`, and `copy()` which is very convenient. This reduces boilerplate and clearly signals the intent of the class as a simple container.
- **Use Default and Named Arguments:** Take advantage of default parameter values in functions to simplify overloads. For example: `fun connect(host: String, port: Int = 80, useSsl: Boolean = true) { ... }`. Callers can omit optional parameters or use named arguments for clarity (e.g., `connect(host = "example.com", useSsl = false)`). Named arguments improve readability when a function has multiple parameters of the same type or boolean flags.
- **Prefer Kotlin Collections & Operations:** Use Kotlin's extensions on collections (like `filter`, `map`, `forEach`, etc.) for more functional style operations. Prefer immutable list/map (`listOf`, `mapOf`) when you don't need to mutate a collection. Use sequences (`sequence { }` or `.asSequence()`) for large collections or chains of operations to avoid building intermediate collections.
- **Avoid Primitive Array Use:** Prefer Kotlin's typed arrays (`IntArray`, `DoubleArray`, etc.) or lists (`List<Int>`) unless you have a specific need for low-level arrays. In most cases, List or the specialized array classes provide more safety and utility. If you do use arrays, Kotlin's array literals and factory functions (like `arrayOf`) can help.
- **No Semi-colons:** It's obvious, but don't use semicolons at line ends in Kotlin – they are optional and idiomatically omitted.

### Kotlin Best Practices
- **Extension Functions:** Use extension functions to add utility behavior to classes, especially if you find yourself writing helper functions that take a class as a parameter. For example, if you often need to format a Date in a certain way, write `fun Date.format(): String { ... }`. This makes the call site read naturally (`date.format()`) and organizes code logically (extensions can be grouped by the extended type).
- **Higher-Order Functions & Lambdas:** Embrace Kotlin's first-class function support. Instead of interfaces with single methods (like Java's listener patterns), you can often pass lambda functions. For example, use `filter { it.isActive }` on a collection rather than writing a loop. When designing APIs, consider providing functions that take lambdas for callbacks or processing logic. Use `inline` functions for higher-order functions that would otherwise create a performance overhead with lambdas in hot paths.
- **Use `when` for Clear Branching:** `when` is a powerful replacement for switch and if-else chains. Use `when` especially for checking enum cases or sealed class variants – it forces exhaustiveness if used as an expression. For example: `when(val result = apiCall()) { is Success -> println("Got ${result.data}"); is Error -> println("Failed: ${result.exception}") }`. If result is a sealed class, this when will give a compiler error if a case is unhandled, which is great for safety.
- **Prefer Immutable Data Structures:** Similar to general advice – use `val` and immutable collections. If you need to expose a list from a class, consider exposing it as an unmodifiable list (Kotlin doesn't have a direct analog of `Collections.unmodifiableList`, but you can return a `List<T>` interface type backed by an internal mutable list, or use `toList()` to return a copy).
- **Use `object` for Singletons and Utility Classes:** If you have a class that should only have one instance (like a singleton or a utility collection of functions), use `object` instead of a class with a private constructor. An `object` in Kotlin is a singleton that is instantiated on first access. It's perfect for stateless utility functions grouped together, or for single-instance services. For example: `object Config { val MAX_RETRIES = 3; fun load() { ... } }`. Then use `Config.load()` directly.
- **Sealed Classes for Closed Hierarchies:** When you have a concept with limited variants (especially for representing results or state machines), use sealed classes. They allow creating a closed set of subclasses, and when combined with `when` ensure you handle all cases. For example, a sealed class `Result` with subclasses `Success` and `Error`. This can eliminate the need for error-prone enum-with-data or exception-based flow.
- **Coroutine Best Practices (if using coroutines):** Use `suspend` functions to make asynchronous code sequential and readable. Prefer launching coroutines via structured concurrency (e.g., via `CoroutineScope.launch` within appropriate scopes like `viewModelScope` in Android or using `runBlocking` in main functions for scripts). Do not ignore coroutine `Deferred` or job results – always handle exceptions (e.g., with try-catch inside a coroutine or using `.catch` on flow). Use the right dispatcher for the job (Main, IO, Default) and avoid blocking threads in a coroutine (use `withContext(Dispatchers.IO)` for blocking I/O). Cancel coroutines when their work is no longer needed to avoid leaks (structured concurrency helps with this by canceling child coroutines when a scope is canceled).
- **Interop Considerations:** If intermixing with Java: Use Kotlin's `@JvmOverloads` for providing overloads of Kotlin functions to Java when you have default parameters. Use `@JvmStatic` for members inside companion objects that need to be called from Java in a natural way. Be mindful of Kotlin's nullability when calling Java code (Java's types are treated as platform types `T!` which can be either; consider annotating Java code with nullability annotations if you control it). Prefer Kotlin collections/types in your APIs, but if Java callers are common, ensure your APIs are Java-friendly (for instance, returning `List<T>` is fine, but returning a Kotlin-specific type might not be). Avoid excessive use of `!!` or platform types: If calling Java code, try to handle possible nulls in Java results immediately, converting to either non-null types with a default or throwing an exception, rather than letting nulls propagate widely in Kotlin as platform types. The goal is to contain unsafely nullable types at the boundary and convert to safe types in Kotlin.

### Kotlin Common Pitfalls to Avoid
- **Do Not Overuse `var`:** Reiterating – default to `val`. If you find yourself needing to reassign a variable frequently, ask whether a different approach (like using a loop, different data structure, or creating a new value instead of modifying one) would be clearer or safer.
- **Avoid Non-Idiomatic Java Patterns:** Don't write Kotlin as if it were Java: Avoid manual getters and setters; use Kotlin properties. Don't use raw loops for everything if a higher-order function or sequence is clearer. Avoid using exceptions for flow control; prefer returning sealed class results or Kotlin's built-in result mechanisms. Refrain from creating excessive utility classes; Kotlin's top-level functions in files or extension functions are often better.
- **Be Careful with Top-Level Functions:** Top-level functions are fine for utilities, but organize them well (group in files with meaningful names, possibly mark `internal` if they're not part of the public API). Overuse of top-level functions can lead to a cluttered global namespace. Consider using `object` or companion object if some state or grouping is needed.
- **Use Proper Scoping Functions Intentionally:** Kotlin's scoping functions (`let`, `apply`, `run`, `also`, `with`) are powerful but can be confusing if misused. Use `apply` when configuring an object (it yields the object), `let` when doing something with an object (it yields the result of the block), etc. Don't just chain them arbitrarily; ensure it improves readability. A long chain of mixed scoping functions can be hard to follow.
- **Prefer Immutable Data Structures/DTOs:** If you're using Kotlin data classes for DTOs, try to keep them immutable (all `val`). If a field needs to be mutable, document why. This ties back to immutability helping with thread-safety and reasoning about code.
- **Testing in Kotlin:** Use Kotlin's rich stdlib in tests for brevity (like multi-line strings `"""` for expected outputs, etc.). When using JUnit, you can use kotlin-test assertions or extension functions to write fluent tests. Also, consider using coroutines test libraries if testing suspend functions (e.g., `runTest` from KotlinX Coroutines test to test suspend code).

---

## JavaScript/TypeScript Guidelines
JavaScript and TypeScript share a runtime (when TS is compiled) but TS adds static typing. These guidelines cover both, with distinctions noted.

### JavaScript Best Practices
- **Use Strict Mode:** Always enable strict mode (`"use strict";` at the top of scripts or functions, or configure your bundler/ES modules which are strict by default). Strict mode catches common mistakes (like assigning to undeclared variables) and prevents certain unsafe actions.
- **Prefer `const`/`let` over `var`:** Do not use `var` in modern JS/TS. Instead, use `const` by default, and `let` if you need to reassign a variable. `const` signals that a variable should not be reassigned, which aids readability and avoids many scoping issues. `let` has block scope (unlike `var`). Using `var` can lead to bugs due to hoisting and scoping confusion.
- **Avoid Global Variables:** Do not pollute the global scope. Always declare variables (with `const`/`let`). When needing truly global variables (rare), explicitly attach them to `window` or `globalThis` in a controlled manner. Use IIFEs or ES6 modules to encapsulate code. This prevents naming collisions and inadvertent interactions between scripts.
- **Use Strict Equality:** Always use `===` and `!==` instead of `==` or `!=`. The strict equality operators do not perform type coercion, which avoids subtle bugs (e.g., `"" == 0` is true, but `"" === 0` is false, which is usually what you want). In the rare case you need type-coercing comparisons, be very explicit (or better, convert types yourself before comparison).
- **Consistent Naming and Style:** Use **camelCase** for variables and functions (e.g. `let totalCount = 5; function sendEmail() {...}`). Use **PascalCase** for constructor functions or classes (e.g. `function DataModel() {...}` or `class DataModel {...}`). Use **UPPER_SNAKE_CASE** for constants that are truly constant (e.g. configuration values). In JavaScript, you can signal a value shouldn't change by naming it in caps, even though the language doesn't enforce it. File and directory naming: many projects use kebab-case or snake_case for filenames (e.g. `user-controller.js`), but ensure consistency within your project.
- **Semicolons:** Follow your team/project convention on semicolons. Many style guides still recommend ending statements with semicolons to avoid ASI pitfalls. If you choose to omit semicolons, be disciplined about situations where automatic semicolon insertion can break (starting a line with `[` or `(`, for example). Using a linter/formatter can enforce whichever convention you choose.
- **Use Functions and Block Scoping Appropriately:** Understand function scope vs block scope. `let` and `const` are block-scoped, which is usually what you want for loops and conditionals. Avoid using loops with `var` and then issues with closure capturing. For example, when creating functions in a loop, use `let` for the index or use array iteration methods to avoid common closure mistakes.
- **Modularize Code:** Organize code into functions and modules. Don't write huge monolithic functions or scripts. Use ES6 modules (`import`/`export`) or CommonJS modules (`require`/`exports` in Node) to split functionality into separate files by feature or layer. This improves maintainability and reuse.
- **Error Handling:** Use `try...catch` around code that can throw (JSON parsing, network requests using fetch/axios, etc.) and handle errors gracefully. In Node.js, handle promise rejections or use `.catch()` on promises to avoid unhandled rejections. Always provide some error feedback or logging, even if it's just `console.error` in a small script, so errors don't fail silently.
- **Console and Debugging:** Remove or disable `console.log`/debug prints in production code, or use a proper logging library with log levels. Too many stray `console.log` statements clutter output and can even leak sensitive info. Instead, use breakpoints or conditional logging during development, and a controlled logging mechanism for production.
- **Avoid Blocking the UI (in browser):** Be mindful that JavaScript on the web is single-threaded (with asynchronous callbacks). Don't perform heavy computations or loops for too long without yielding, as it will freeze the UI. For large computations, consider splitting work using `setTimeout(…, 0)` breaks, Web Workers, or using streaming approaches. Similarly, avoid synchronous XHR or other blocking calls in the main thread.
- **DOM and Web APIs:** If manipulating the DOM, batch DOM changes to minimize reflows (e.g., build a fragment or use a single `innerHTML` update rather than append in a loop). Use modern DOM methods (like `querySelector` instead of older `getElementById` when appropriate). Clean up event listeners or intervals you set to avoid memory leaks.
- **Equality Gotchas:** In addition to `===` rules, be careful with `NaN` and floating point. Know that `NaN !== NaN` (use `Number.isNaN()` to check NaN). For floating point, never compare directly for equality if there could be rounding (allow a tolerance).
- **Use ES6+ Features:** Embrace modern JavaScript features for cleaner code: Destructuring: e.g. `const { name, age } = user;` to extract properties. Spread operator: e.g. `const newArr = [...oldArr, newItem]` or object spread `{...obj, newProp: 42}` for shallow copies. Arrow functions: use them for short callbacks, especially because they preserve the `this` context of the enclosing scope which avoids the need for `.bind(this)` in many cases. Template literals: as mentioned, for string construction instead of concatenation. `for...of` loops for arrays (or `.forEach`), and `for...in` for objects (with appropriate `hasOwnProperty` guard if needed) instead of traditional indexed loops when not necessary. Default parameters: `function foo(x = 10) { ... }` instead of checking `x || 10` inside.
- **Functional Array Methods:** Use array methods like `map`, `filter`, `reduce` to make code more declarative, but ensure the intent remains clear. For complex transformations, sometimes a simple loop may be clearer. Avoid abusing `reduce` for everything; use it when it truly simplifies or when you need to accumulate a result that isn't easily obtained with other methods.
- **Linting:** Use ESLint (with a standard style guide like Airbnb, Google, or StandardJS, or your custom rules) to catch common issues and enforce consistent style. This will catch things like unused variables, undefined variables, problematic constructs, etc., before runtime.

### TypeScript Best Practices
- **Leverage Static Types Fully:** TypeScript's biggest advantage is compile-time checking. Embrace it: Type Everything Important: Give types to function parameters and return types, especially for public functions. Use interfaces or type aliases for complex structures instead of `any`. The only time you might use `any` or `unknown` is when interfacing with truly dynamic data or migrating legacy code – even then, try to minimize its usage.
- **Prefer Interfaces and Type Aliases Appropriately:** Use `interface` for describing object shapes and contracts, especially for public API surfaces (it can be extended and merged). Use `type` aliases for unions, tuples, or more complex mapped types. In many cases they can be used interchangeably, but many style guides suggest preferring interfaces for object types and type aliases for everything else.
- **Avoid `any` and `!`:** Try not to resort to `any`. If you must gradually type a codebase, use `unknown` which forces usage checks, or better, find a proper type. The non-null assertion (`foo!`) should also be rare – it's basically telling the compiler "trust me, it's not null/undefined." Overusing it defeats the purpose of the type system. Instead, handle null/undefined cases with union types and conditional checks.
- **Strict Compiler Settings:** Enable strict mode (`"strict": true` in tsconfig) and other helpful flags (`noImplicitAny`, `strictNullChecks`, etc.). These catch more issues early. It might be extra work to satisfy the compiler, but it pays off in reliability.
- **Use Union and Enum Types for Clear States:** Instead of using magic strings or numbers, use TypeScript's union types or enum for a set of possible values. For example: `type HttpMethod = "GET" | "POST" | "PUT" | "DELETE"; function request(method: HttpMethod, url: string) { ... }`. This way `request("GARBLE", "/")` will be a compile error. Enums are also useful if you need a full enumeration (though some prefer union types or `as const` arrays for better TS inference).
- **Narrow Types with Type Guards:** Use `typeof`, `instanceof`, or custom type predicate functions to narrow types in conditional blocks. For example: `if (typeof value === "string") { /* here 'value' is treated as string */ }` or for custom objects: `function isCustomer(x: User | Customer): x is Customer { return (x as Customer).purchaseHistory !== undefined; }`. Then you can do `if (isCustomer(user)) { /* user is Customer in this block */ }`. This makes code safer and avoids a lot of type casting.
- **Generics for Reusable Components:** If writing functions or classes that can operate on multiple types, use generics to preserve type information. For example, a function to wrap a value could be `function wrapInArray<T>(value: T): T[] { return [value]; }` so it returns the proper array type.
- **Structural Typing Awareness:** Remember TypeScript is structurally typed (duck typing). Be careful when two different interfaces have the same structure – the compiler will consider them interchangeable. If you intend distinct brands, you can add a private dummy field or use nominal typing tricks or branded types.
- **Avoid Overly Broad or Loose Types:** It might be tempting to use something like `any[]` or `{ [key:string]: any }`, but try to be more precise. If you have an object with known keys, define an interface for it. If a function returns either a specific type or null, use `Type | null` rather than `any`.
- **Leverage Utility Types:** TypeScript provides many utility types (Partial, Omit, Pick, Record, etc.). Use them to avoid repetition. For example, if a function takes an object similar to another but with one property optional, use `Partial<OtherType>` or `Omit` to derive it.
- **Avoid `require` in TS:** Use ES import/export syntax. It works better with TS's module system. Only use `require()` for special cases (e.g. conditionally loading something or when a module doesn't have types, and even then you can use `import type` or ambient declarations).
- **Namespaces vs Modules:** Avoid old TypeScript namespace (formerly internal modules) unless you have a specific need. Use ES6 modules for organizing code. Namespaces can be useful in `.d.ts` files or to organize a large file's content, but generally modules are the standard now.
- **StrictNullChecks and Optional Chaining:** With strict null checks on, make use of optional chaining (`obj?.prop`) and nullish coalescing (`??`) to handle possibly undefined values succinctly. For example, `const length = data?.items?.length ?? 0;` safely handles if `data` or `items` is undefined. This keeps code safe and shorter.
- **DOM and TS:** If working with the DOM, use the types provided by TypeScript (like `HTMLElement`, `HTMLDivElement`, etc.). Use type assertions when you have to, e.g. `document.getElementById('foo') as HTMLInputElement` if you know the element is an `<input>`. But try to narrow via code if possible (query for specific selectors that infer the type, like `document.querySelector<HTMLCanvasElement>('#canvas')` which can directly give a typed element).
- **tsconfig and Compiler:** Keep your `tsconfig.json` updated to include relevant paths, libs (DOM, ES2021, etc.), and enable useful flags. This ensures consistent compilation. Also, if using a bundler, integrate source maps for easier debugging.
- **Linting and Formatting:** Use TSLint or the now more common ESLint with TypeScript plugins to enforce style and catch issues (like forgetting to await a promise, or using deprecated features, etc.). Also use Prettier or an ESLint rule set to format code for consistency.
- **Prefer Async/Await:** In TypeScript (and modern JS), prefer using `async/await` for asynchronous code instead of raw Promises or callbacks. It makes control flow more readable. Ensure you catch errors from async functions (using try/catch inside an async function, or using `.catch` on the promise).
- **Front-End vs Node Types:** Include proper typings depending on environment. For Node.js, include `@types/node`. For front-end, include the DOM lib. This ensures APIs are recognized (for example, using `fs` requires Node types, using `document` requires DOM lib).
- **Avoid DOM Manipulation in Angular/React/etc:** If using frameworks like React or Angular, do not manually manipulate the DOM – use the framework's methods (React state, Angular templates, etc.). This is more of a framework rule, but given TS is often used with these, it's worth noting.
- **Build and Test:** Continuously build or use an editor that highlights TypeScript errors as you code. Don't ignore compiler errors or warnings – they are there to prevent future bugs. Write tests for complex logic just as in any language.

### JS/TS Pitfalls
- **Floating Point Issues:** Remember that `0.1 + 0.2 !== 0.3` due to floating point precision. If doing financial or precise calculations, consider using integer cents or a big number library.
- **`this` Binding:** In JavaScript, the value of `this` can be tricky. In classes, ensure you bind methods if passing them around (or use arrow functions for class methods where possible, as an arrow function property will lexically bind `this`). In TypeScript, you can use the `functionName = () => {}` class field syntax to create methods that auto-bind. Also beware of losing `this` context when destructuring methods: e.g., `const f = obj.foo; f();` – here `this` is lost. Bind or call with correct context if needed.
- **Iteration:** Don't use `for..in` on arrays (it iterates keys, not values, and includes custom properties). Use `for..of` or array methods. Also, when iterating objects with `for..in`, use `if (obj.hasOwnProperty(key))` inside to skip prototype properties.
- **Prototype Extensions:** Don't modify built-in prototypes (like adding methods to `Array.prototype` or `String.prototype`) in application code; it can cause conflicts (except polyfills, which should be applied carefully if needed). Use your own utilities or modern methods.
- **Shadowing Variables:** Avoid reusing variable names in nested scopes (especially in JS where `var` scoping can cause confusion). In TS/ES6 with `let/const` this is less severe (block scoped), but still, choose distinct names to avoid hiding outer variables unintentionally.
- **Hoisting Surprises:** Be aware that function declarations and `var` are hoisted. For example, you can call a function declared later in a file due to hoisting. While it works, it can be confusing; it's often clearer to define functions before usage or use function expressions. In any case, avoid relying on hoisting behavior as it can reduce clarity.
- **Promises:** Always handle both resolve and reject of promises. If you have an unused promise (e.g., calling an async function without `await` in an async context), consider adding `.catch()` to it or explicitly ignore it with a comment if it's truly okay to ignore (to satisfy linters). Unhandled promise rejections can terminate Node processes (in strict modes) or go unnoticed in browsers.
- **Catching Errors in Async code:** In an async function, use try/catch around `await` calls if you want to handle errors locally. Otherwise, let it bubble to a higher-level handler or an outer `Promise.catch`. Missing error handling is a common source of silent failure in JS.
- **ES Module vs CommonJS Confusion:** If using TypeScript, be mindful of your module setting (ESNext, CommonJS, etc.). In Node with TS, consider using ES modules (with `"module": "ES2022"` and `.mts` extensions, for example) for forward-compatibility, or stick to CommonJS if needed but know how to import accordingly. Mismatching module types can lead to runtime errors where imports are undefined or similar.

## Project Specific Rules
- **Create a new branch:** Before making any changes, ensure a valid ticket or branch name is provided. If none exists, request one. Create a new branch using the ticket reference and match existing branch naming conventions.
- **No tests:** Focus on implementing functionality - testing is handled separately. Do not create or modify test files unless specifically requested.
- **Create a plan:** Create or modify a `todo.md` with the plan to track changes and improvements needed in the task. This allows structured task management and enhancement tracking.
- **Don't make assumptions:** Ask for instructions if something is not clear.
- **Keep it short and clean:** Make every task and code change as simple as possible. Avoid massive or complex changes. Every change should impact as little code as possible. Everything is about simplicity.